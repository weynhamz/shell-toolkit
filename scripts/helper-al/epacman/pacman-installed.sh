#!/bin/bash
#
# Filename: epacman.sh
#

export LC_ALL=C

#
# Assign heredoc statement to a variable
#
# See: http://stackoverflow.com/questions/1167746
#
# A space character after a '\' at the end of line is necessary.
#
__help=$(cat << 'EOF'

View system packages information in a pretty style.

Usage:

    epacman.sh [-t] (([-g] [-l]) [-D] [-R]) \
               [-h|--help] [-e|--explicit] [-d|--dependency] \
               [(-f|--file) (-|<file>)] [-o|--output]

Options:

    -t  Debug mode
    -g  List packages group
    -l  List packages not in any group
    -D  List packages dependency
    -R  List packages requirements
    -h, --help
        Help information
    -e, --explicit
        Show explicitly installed packages
    -d, --dependency
        Show packages intalled as dependency
    -f, --file (-|<file>)
        Read packages information from <file> or stdin(-)
        Packages information be the result generated by
        'pacman -Q' in ASCII.
    -o, --output
        Output packages information to stdout or <file> if '-f' is set.
EOF
)

#
# File name: epacman.awk
#
# Usage:
#
#     epacman.awk [-t] (([-g] [-l]) [-D] [-R]) <filename>
#     epacman.awk [-t] (([-g] [-l]) [-D] [-R]) < <inputstream>
#
#     Filename or Inputstream must be the result generated by
#     'pacman -Q' in ASCII.
#
# Options:
#
#     -t  Debug mode
#     -g  List packages group
#     -l  List packages not in any group
#     -D  List packages dependency
#     -R  List packages requirements
__epacman=$(cat << 'EOF'
    #
    # Get Array Size
    #
    function size(array) {
        count = 0;
        for(item in array) {
            count++;
        }
        return count;
    }

    #
    # Compare two strings alphabetically
    #
    # If a is before b return 1, else return 0.
    #
    function comp(a,b) {
        if(a=="" || b=="") return 3;
        if(substr(a,1,1) > substr(b,1,1)) {
            return 1;
        } else if(substr(a,1,1) < substr(b,1,1)) {
            return 0;
        } else if(substr(a,1,1) == substr(b,1,1)) {
            if (length(a) == 1) {
                return 0;
            } else if (length(b) == 1) {
                return 1;
            } else {
                return comp(substr(a,2),substr(b,2));
            }
        }
    }

    function ksort(array,n)
    {
        max = "";
        if(n == "")
            n=size(array);
        for(item in array) {
            result = comp(item,max);
            if(array[item] <= n && result) {
                max = item;
            } else if(array[item] == n){
                print item;
            }
        }
        array[max] = n;
        if(n ==0) {
            for (l=1;l<=size(array);l++) {
                for(item in array) {
                    if(l == array[item]) {
                        array[l]=item;
                        delete array[""];
                        delete array[item];
                    }
                }
            }
        } else {
            ksort(array,n-1);
        }
    }

    function var_dump(array){
        printf("VAR_DUMP:\n");
        for(item in array){
            printf("\033[40m%s:%s\033[0m\n",item,array[item]);
        }
        printf("\n");
    }

    BEGIN {
        FS = ":";
        #Process the args
        while((c = getopt(ARGC, ARGV, "tlgDR")) != -1)
        {
            switch (c) {
            case "t":
                debug=1;
                continue
            case "l":
                show_list=1;
                continue
            case "g":
                show_group=1;
                continue
            case "D":
                show_depend=1;
                continue
            case "R":
                show_require=1;
                continue
            }
        }
        #Clear out options, in case
        #of being used as filenames
        for(i=1;i<Optind;i++){
            delete ARGV[i]
        }
    }

    {
        if(length($0) == 0) {
            if(groups != "None")
            {
                if(show_group) {
                    split(groups,buffer,"  ");
                    asort(buffer);
                    for(i=1;i<=size(buffer);i++)
                    {
                        group = buffer[i];
                        ggroups[group] = group;
                        egroups[group,name] = name;
                    }
                } else {
                    left[name] = name # "[Groups:" groups "]"
                }
            }
            else
            {
                left[name]=name;
            }
            if(requireby != "None")
            {
                split(requireby,requirebys," ");
                asort(requirebys);
                for(i=1;i<=size(requirebys);i++) {
                    require=requirebys[i];
                    requires[name,require]=require;
                }
            }
            if(dependson != "None")
            {
                split(dependson,dependsons," ");
                asort(dependsons);
                for(i=1;i<=size(dependsons);i++){
                    depend=dependsons[i];
                    depends[name,depend]=depend;
                }
            }
        } else {
            gsub(/^[ ]+/,"",$1);
            gsub(/[ ]+$/,"",$1);
            gsub(/[ ]+$/,"",$2);
            gsub(/^[ ]+/,"",$2);
            if($1 == "Name")
            {
                name = $2;
            }
            else if($1 == "Groups")
            {
                groups = $2;
            }
            else if($1 == "Depends On")
            {
                dependson = $2;
            }
            else if($1 == "Required By")
            {
                requireby = $2;
            }
            else if($1 == "Description")
            {
                description = $2;
            }
            else if($1 == "Install Reason")
            {
                installreason = $2;
            }
        }
    }

    END {
        if(debug) {
            asort(left);
            for(i=1;i<=size(left);i++) {
                count = 0;
                for (item in requires) {
                    split(item,items,"\034");
                    if(left[i] == items[1])
                    {
                        count++;
                    }
                }
                if (count == 0) printf("%d:%s\n",i,left[i]);
            }
        }
        if(show_list) {
            asort(left);
            for(i=1;i<=size(left);i++) {
                printf("%d:%s\n",i,left[i]);
                if (show_depend)
                {
                    for (item in depends) {
                        split(item,items,"\034");
                        if(left[i] == items[1])
                        {
                            printf("    |== %s\n",items[2]);
                        }
                    }
                }
                if (show_require)
                {
                    for (item in requires) {
                        split(item,items,"\034");
                        if(left[i] == items[1])
                        {
                            printf("    |** %s\n",items[2]);
                        }
                    }
                }
            }
        }
        if(show_group) {
            asort(ggroups);
            for(i=1;i<=size(ggroups);i++){
                printf("%s\n",ggroups[i]);
                for(item in egroups) {
                    split(item,items,"\034");
                    if ( ggroups[i] == items[1]) {
                        package = items[2];
                        temp[package] = package;
                    }
                }
                asort(temp);
                for(j=1;j<=size(temp);j++) {
                    printf("  |-- %s\n",temp[j]);
                    if (show_depend)
                    {
                        for (item in depends) {
                            split(item,items,"\034");
                            if(temp[j] == items[1])
                            {
                                printf("  |  |== %s\n",items[2]);
                            }
                        }
                    }
                    if (show_require)
                    {
                        for (item in requires) {
                            split(item,items,"\034");
                            if(temp[j] == items[1])
                            {
                                printf("  |  |** %s\n",items[2]);
                            }
                        }
                    }
                }
                delete temp;
                printf("\n");
            }
        }
    }
EOF
)

#
# Get current directory
#
# From: http://stackoverflow.com/questions/59895
#
_current_path() {
    SOURCE="${BASH_SOURCE[0]}"
    DIR="$( dirname "$SOURCE" )"
    while [ -h "$SOURCE" ]
    do
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd )"
    done
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    echo $DIR
}

_packages_info() {
    if [ -n "$explicit" ]; then
        packages=$(pacman -Qe)
    elif [ -n "$dependency" ]; then
        packages=$(pacman -Qd)
    else
        packages=$(pacman -Q)
    fi

    echo "$packages" | cut -d' ' -f 1 | xargs pacman -Qi
}

while [ $# -gt 0 ]
do
    case $1 in
        -h | --help)
            echo "$__help"
            exit 0
            ;;
        -f | --file)
            file=$2
            shift
            ;;
        -o | --output)
	        output=TRUE
            ;;
        -t)
            debug=TRUE
            args_awk=$args_awk" $1"
            ;;
        -l)
            args_awk=$args_awk" $1"
            ;;
        -g)
            args_awk=$args_awk" $1"
            ;;
        -D)
            args_awk=$args_awk" $1"
            ;;
        -R)
            args_awk=$args_awk" $1"
            ;;
        -e | --explicit)
            explicit=TRUE
            ;;
        -d | --dependency)
            dependency=TRUE
            ;;
        -*)
            arg=$1
            arg_2=${arg#-?}
            if [ -n "$arg_2" ]; then
                shift
                arg_1=${arg%$arg_2}
                args_new=$arg' '$arg_1' -'$arg_2' '$@
                set -- $args_new
            else
                echo "Invalid Arg"
                echo "$help"
                exit 1
            fi
            ;;
        *)
            break
            ;;
    esac
    shift
done

if [ -n "$output" ]; then
    packagesinfo=$(_packages_info)
    if [ -n "$file" ]; then
        if [ "$file" = "-" ]; then
            echo "$packagesinfo"
        elif [ -w "$file" ]; then
            echo "$packagesinfo" > $file
        elif [ ! -f "$file" ]; then
            touch "$file"
            echo "$packagesinfo" > $file
        else
            echo "Could not write to file '$file'."
            exit 1
        fi
    else
        echo "$packagesinfo"
    fi
    exit 0
else
    if [ -n "$file" ]; then
        if [ "$file" = "-" ]; then
            packagesinfo=$(cat)
        elif [ -f "$file" ]; then
            packagesinfo=$(cat $file)
        else
            echo "File '$file' does not exist."
            exit 1
        fi
    else
        packagesinfo=$(_packages_info)
    fi
fi

set -- $args_awk

echo "$packagesinfo" | awk -i /usr/share/awk/getopt.awk -- "$__epacman" "$@"
